# SM2 实验说明

## 实验目的与背景

本实验通过 Python 实现 SM2 算法，深入理解其数学原理、软件实现和安全风险。实验分为三部分：

1. **SM2 基础实现与性能优化**
2. **签名算法误用分析及 PoC 验证**
3. **伪造中本聪数字签名演示**

通过本实验，学生能够：

* 掌握 SM2 算法核心运算（点加法、标量乘法、签名与验签、加密解密）
* 学习软件优化方法（T-Table、缓存优化、批量计算等）
* 理解签名算法误用与安全风险
* 通过 PoC 验证签名伪造原理

---

## 实验一：SM2 基础实现与性能优化

### 1.1 实验目标

* 完成 SM2 算法的 Python 实现
* 理解椭圆曲线点运算及密钥生成
* 对比优化前后的性能差异

### 1.2 实验内容

1. **基础实现**

   * 点加法 `point_add`
   * 标量乘法 `point_mul`
   * 签名 `sm2_sign` 与验签 `sm2_verify`
   * 加密 `sm2_encrypt` 与解密 `sm2_decrypt`

2. **性能优化方法分析**

| 优化方法                  | 原理                          | 预期效果                  |
| --------------------- | --------------------------- | --------------------- |
| **T-Table 预计算**       | 将 G 的多倍点预计算，使用窗口法减少标量乘法循环次数 | 提升标量乘法和加解密性能，适合重复运算场景 |
| **缓存优化 / 查表**         | 对 S-Box 或重复运算结果缓存，提高局部访问效率  | 减少重复计算，适合签名和批量加解密     |
| **批量计算（NumPy 异或优化）**  | 对多条消息同时进行加解密，利用矩阵运算加速       | 提升吞吐量，减少每条消息平均延迟      |
| **硬件加速（AES-NI/GFNI）** | 使用 CPU 指令加速 S-Box/字节操作      | 大幅降低单条消息加解密时间，适合高性能应用 |

3. **实验方法**

   * 对比 `point_mul` 与 `fast_mul`（T-Table 窗口法）计算结果是否一致
   * 可选：对批量消息加密解密测试吞吐量

---

## 实验二：签名算法误用分析及 PoC 验证

### 2.1 实验目标

* 分析 SM2 签名算法误用导致的私钥泄露风险
* 基于 PoC 演示攻击效果

### 2.2 实验内容

1. **常见误用场景**

   * 重复使用随机数 k
   * 非随机 k 或固定 k

2. **数学推导**

对于重复 k 的两条消息签名：

$$
s_1 = (1+d)^{-1}(k - r d), \quad s_2 = (1+d)^{-1}(k - r d)
$$

可求出私钥 $d$：

$$
d = ((s_1 - s_2) * (r_1 - r_2)^{-1} - 1) \mod n
$$

3. **PoC 验证**

* Python 实现重复 k 恶意签名
* 恢复私钥并验证是否成功

示例代码：

```python
# 生成密钥
d, P = gen_keypair()

# 固定随机数 k
k_fixed = random.randint(1, sm2_curve['n']-1)
msg1, msg2 = "Hello SM2", "Hello Attack"

r1, s1, _ = sm2_sign_fixed_k(msg1, d, k_fixed)
r2, s2, _ = sm2_sign_fixed_k(msg2, d, k_fixed)

# 恢复私钥
n = sm2_curve['n']
d_recovered = ((s1 - s2) * pow(r1 - r2, -1, n) - 1) % n
print("恢复成功:", d_recovered == d)
```

---

## 实验三：伪造中本聪数字签名

### 3.1 实验目标

* 演示在不知私钥情况下，构造伪造签名，使公钥验证通过
* 理解数字签名数学原理及漏洞

### 3.2 实验原理

* 随机选择 $u, v$
* 构造伪造点 $R = uG + vP$
* 设置签名：

$$
r = R_x \mod n, \quad s = r u^{-1} \mod n
$$

* 构造消息哈希：

$$
e = r v u^{-1} \mod n
$$

* 验证公式满足：

$$
s^{-1} (e G + r P) = R
$$

### 3.3 PoC 验证

```python
u, v = random.randint(1,n-1), random.randint(1,n-1)
R = point_add(point_mul(u,G), point_mul(v,P), sm2_curve)

r = R.x % n
s = (r * pow(u, -1, n)) % n
e = (r * v * pow(u, -1, n)) % n

t = (r + s) % n
R_check = point_add(point_mul(s, G), point_mul(t, P), sm2_curve)
print("验签是否通过:", r == R_check.x % n)
```

---

## 实验总结

1. 通过 Python 实现 SM2 算法，加深对椭圆曲线运算的理解
2. 学习 T-Table、缓存优化、批量计算等性能优化方法
3. 了解签名算法误用可能导致的私钥泄露
4. 通过 PoC 演示伪造签名攻击，提高安全意识
