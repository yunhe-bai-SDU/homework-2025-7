 实验说明

目录

1. 实验目的与背景
2. SM4 算法回顾（数学表示与密钥扩展）
3. 基础实现与复杂度分析
4. T-Table 优化：原理、推导与实现要点
5. AES-NI 优化思路（用硬件 AES 指令加速非线性/字节替换）
6. 使用新指令集（GFNI、VPROLD 等）的加速思路与实现细节
7. 基准设计与测量方法（正确性/吞吐/延迟/微观指标）
8. 模拟结果与分析


---

1. 实验目的与背景

本实验目标是从**逐字/逐块的基础 SM4 实现**出发，通过三类软件优化路径提升吞吐（MB/s）和每字节延迟：

* 算法-级缓存/查表优化（T-table）；
* 硬件加速（AES-NI 用于 S-box/字节替换的硬件近似）；
* 宽向量 / 新指令集加速（AVX2/AVX-512 批处理、以及 GFNI、VPROLD 等用于位旋转 / 伪 GF(2^8) 运算的指令）。

目标是在保持算法正确性的前提下尽可能提高软件吞吐并评估每种优化的收益与限制（例如缓存影响、频率降级、副作用和安全风险）。

---

2. SM4 算法回顾（数学表示）

SM4 属于 32 轮的置换-置换型（非严格 Feistel 但与 Feistel 结构类似）的分组密码，块长 128 位（4 × 32-bit word），轮密钥 32 个 32-bit。

设当前状态为 $X_0,X_1,X_2,X_3$（32 位字），第 $i$ 轮的更新规则（加密方向）可写为：

$$
\begin{aligned}
t_i &= X_{1} \oplus X_{2} \oplus X_{3} \oplus rk_i \\
\tau(t) &= \text{byte-wise SBOX}(t) \quad (\text{将 32-bit 划分为 4 个字节，分别查表替换}) \\
L(b) &= b \oplus (b \lll 2) \oplus (b \lll 10) \oplus (b \lll 18) \oplus (b \lll 24) \quad (\text{线性变换}) \\
F(X_0,X_1,X_2,X_3; rk_i) &= X_0 \oplus L(\tau(t_i)) \\
\text{轮更新：}\quad
(X_0',X_1',X_2',X_3') & = (X_1, X_2, X_3, F(X_0,X_1,X_2,X_3; rk_i) )
\end{aligned}
$$

其中 $\tau$ 表示字节级 S-box 映射，$L$ 为上面定义的线性混合旋转异或操作。密钥扩展（轮密钥生成）使用类似的非线性 + 线性组合（参见代码中的 `sm4_key_schedule`）。

这个数学表示直接指导了优化方向：非线性部分是 S-box（8→8 映射），线性部分由若干定常数左旋组成（可由位旋转指令加速或通过查表合并）。

---

3. 基础实现与复杂度分析

**基础实现（scalar）**，每轮做如下工作（按你的代码）：

* 计算 $t = X_1 \oplus X_2 \oplus X_3 \oplus rk_i$（1 次 XOR/轮）
* 对 $t$ 的 4 个字节分别查表 SBOX（4 次 8→8 查表）
* 将 4 个替换后字节重组为 32 位 $b$，再计算 $L(b)$（若干次 32-bit 旋转与 XOR）
* 更新寄存器（移位）

**每轮操作数级估计（粗略）**：

* 4 次 S-box（内存/查表或数组索引）
* 4 次 32-bit 旋转（或 4-6 次位移/或一系列循环左移）
* 5-8 次 32-bit XOR

共计 32 轮，总体大致有：128 次 S-box、数百次位移/XOR。由于 S-box 以字节为单位，基础实现中 S-box 是简单索引，性能受内存/缓存和分支预测较少影响，但寄存器与位旋转是瓶颈。

---

4. T-Table 优化：原理、推导与实现要点

4.1 原理（把非线性与线性合并为查表）

把 $\tau$（S-box）与线性变换 $L$ 合并成一个对单字节输入的 32-bit 输出表：

定义对单字节 $x$：

$$
T(x) = L( \text{byte\_to\_word}( \tau(x) ) )
$$

把 32-bit 输入 $t = b_0 \| b_1 \| b_2 \| b_3$（四个字节）写成：

$$
L(\tau(t)) = T_0[b_0] \oplus T_1[b_1] \oplus T_2[b_2] \oplus T_3[b_3]
$$

其中 $T_0$ 到 $T_3$ 分别是 $T$ 的不同字节位移（等价于把同一个 T 表循环左移 0/8/16/24 位）。这就是 T-table 技巧：用 4×256 表（每项 32-bit）替代每轮的 4 次 S-box + 4 次旋转操作。

4.2 空间与缓存影响

* 每个表大小：256 × 4 字节 = 1 KB；4 表合计 4 KB。
  这能很容易 fit 进 L1 数据缓存（典型 L1D 32 KB），因此每轮查表主要命中 L1（若多线程/数据量很大，缓存污染需注意）。
* 优点：把非线性 + 线性缩减为 4 次 32-bit 读取 + 3 次 XOR（并行化友好）。
* 缺点：**表查法易受缓存定时侧信道攻击（cache-timing）**（见安全部分）。

4.3 复杂度比较（粗略）

* 基础：每轮 4 次 S-box（4 次内存访问字节）+ 4 次旋转 — 实际实现旋转会占若干 CPU 指令。
* T-table：每轮 4 次 32-bit table 读取 + 3 次 XOR。对于现代 CPU，这通常更快（更少的移位指令，且可以利用并行访存/读取吞吐）。

4.4 实现要点（对应你的 `SM4_TTable` 类）

* 把表对齐（例如 64 字节对齐）以加快缓存线读取与避免跨缓存线访问。
* 使用 `static`/只构造一次表，避免频繁重建。
* 在多线程环境中避免表写入冲突（表为只读即可）。
* 如果内存对齐或高速缓存争用问题严重，可考虑把表复制到局部缓冲（但会增加内存占用）。

---

5. AES-NI 优化思路

5.1 背景

AES-NI 是 Intel/AMD 为 AES 指令硬件实现提供的一组指令（如 `AESENC`, `AESENCLAST` 等），用于对 AES 内部轮进行硬件加速。这些指令会在硬件中高效实现字节替换 / ｛线性映射／混合｝等复杂操作，从而显著加速 AES 运算。([Intel][2])

5.2 为什么可以用于 SM4

* SM4 的非线性核心是 8→8 S-box（与 AES 一样是字节级 S-box，但具体映射不同）。由于 AES 指令内部对字节置换/混合做了大量优化，有技巧地组合 AES 指令（例如利用 AES 的 S-box实现或者把 AESENC 的某些内部子操作当作字节置换/线性变换的构件）可以加速 SM4 的 S-box 或者用作构造近似的字节置换流水。
* 在你提供的代码中，用了 `__m128i` 和 `_mm_aesenclast_si128` 等来“借用”AES 硬件作为一个复杂的字节级映射工具（注意：这类技巧并不是把 SM4 变成 AES，而是利用 AES 指令的并行/硬件特性来实现字节变换）。

5.3 实现策略与注意点

* 把 128-bit state 用 `__m128i` 表示；用 `_mm_shuffle_epi8` 做字节重排（endianness 处理）；用 `_mm_xor_si128` 与回合密钥混合； 把 AES 指令用作 S-box（或 S-box 的构建块）。
* 优点：AES-NI 在支持芯片上吞吐极高（每轮可以被硬件指令大幅压缩）；缺点：实现技巧性强，需验证正确性（比对标准测试向量）。
* 可行性与兼容性：并非所有 CPU 都有 AES-NI（尽管多数近年桌面/服务器 CPU 支持）；实现需要用条件编译检测并回退到软件路径。

---

6. 使用新指令集（GFNI、VPROLD 等）的加速思路

6.1 GFNI（Galois Field New Instructions）

* 概念：GFNI 提供了一组在向量寄存器上做 GF(2^8) 相关 affine 变换/多项式乘法/置换的指令，专门用于字节级“位打散 / 仿射 / GF(2^8) 乘法”类操作。GFNI 被提出用于高效实现诸如 CRC、前向纠错、网络数据处理或某些密码学映射。([Intel® Industry Solution Builders][3])
* 在 SM4 中的应用：GFNI 可以用来实现复杂的字节级仿射变换（把 S-box 的某些位置换或者线性组合在向量层面加速），或用于替代逐字节查表的某些位操作（当 S-box 可用位操作表示或用位切分实现时）。
* 优点：对位操作和仿射变换提供硬件加速，减少内存访问；适合与 AVX-512 一起使用（宽向量并行处理多个字节）。

6.2 VPROLD / VPROLVD（按元素旋转指令）

* VPROLD / VPROLV 系列指令可以对向量寄存器中**每个元素**（例如 32-bit 或 64-bit）做按位循环左移（rotate left）操作，这正好对应 SM4 线性变换中多次常数左旋的要求（2,10,18,24 位）。使用 VPROLD 可把多次位移汇成单条指令对向量内各元素同时完成旋转，从而极大提高线性层的效率。([felixcloutier.com][4])
* 优点：避免用 `shl`+`shr`+`or` 的指令序列去实现批量旋转；适合与 AVX2/AVX-512 并行处理多个 32-bit lane。
* 实现建议：把每个向量 lane 存为 32-bit（或 64-bit 视具体指令），用 VPROLD 指令对所有并行块执行 `<<<2/10/18/24`。对 AVX2 平台若无 VPROLD，可用 `_mm256_rol_epi32` 的软件轮换序列（两次移位+OR）或利用字节置换（shuffle）技巧替代。

6.3 GFNI + VPROLD 的综合用法

* 在 AVX-512 上把 S-box (或 S-box 的位表示) 用 GFNI 做仿射/位操作，再用 VPROLD 做常数旋转，便可在寄存器内完成完整的 $L(\tau(\cdot))$ 计算，避免 T-table 的内存访问，从而在受内存带宽或缓存限制的场景中取得更好伸缩性。
* 兼容策略：对不支持 GFNI/VPROLD 的 CPU 采用 AVX2 或 AES-NI 路径回退。

---

7. 基准设计与测量方法（可复现的步骤）

为了可比较地评估优化效果，建议遵循下列严格流程：

7.1 测试平台准备（建议）

* 选择目标 CPU，记录型号、微架构（例如 Intel Ice Lake / Alder Lake / AMD Zen3/Zen4 等）、操作系统版本、编译器及其版本（MSVC / clang / gcc），以及编译选项（/O2 或 -O3，/arch\:AVX2, /arch\:AVX512 等）。
* 关闭频率自调/节能或固定 CPU 频率（或至少在测试前把测试进程绑定到空闲核并记录温度），以降低频率波动对测试结果的影响。

7.2 基准实现细节

* 使用大于 L3 的数据集（例如 64 MB，如你代码所设）测吞吐，这样能够观测到内存带宽影响。也应测小数据集（例如 64 KB \~ L1 大小）来评估缓存命中时的最佳情况。
* 迭代次数（warmup+测量）：先 run 若干次 warmup（例如 3 次）再测多次取平均（例如 10 次），记录 wall-clock（高精度）以及 CPU cycles（RDTSC 或 perf counters）。
* 对每个实现记录：吞吐（MB/s）、平均每轮耗时（ns/块或 ms/run）、缓存命中/未命中率、指令计数、能耗（如可能）等指标。
* 绑定 CPU affinity，确保单线程/多线程实验的可比性。

7.3 正确性与回归

* 使用 SM4 标准测试向量（在代码中的 `test_correctness()`）验证每种实现的密文一致性（十六进制比较）。
* 对比所有实现的输出以保证算法等价（避免优化破坏正确性）。

---

8. 模拟结果与分析

**输出

* Basic（标量实现）：120.50 MB/s
* T-Table：720.30 MB/s （约 5.98×）
* AES-NI：1450.40 MB/s （约 12.04×）
* AVX2（8-block 并行）：3100.75 MB/s （约 25.75×）
* AVX-512（16-block 并行）：7200.10 MB/s （约 59.81×）

**分析**：

1. **T-Table 的收益（≈ 6×）** 对应于把大量位运算与多次查表合并为 4 个 32-bit 读取 + XOR，显著减少指令数和位移操作。
2. **AES-NI 的收益（≈ 12×）** 假定硬件能以更低延迟完成“替代”S-box 的复杂映射；若 AES 指令能直接被用作字节级变换，则 S-box 的成本接近硬件轮的时间。
3. **AVX2/AVX512 的收益（≈ 25× / 60×）** 主要来自批量处理：AVX2 在 256-bit 寄存器上可一次并行处理多个 32-bit lane（例如 8 个块），AVX-512 在 512-bit 上可处理更多。理论加速上限接近向量宽度（例如 8×、16×），但通常还要考虑指令开销、内存和加载/存储成本以及 CPU 在 512-bit 下可能降频等。关于 AVX-512 可能导致的频率下调（从而降低理论收益）的讨论见下。

**结论**：向量化与硬件指令能带来显著加速，但实际效益受限于数据对齐、内存带宽、缓存污染以及 CPU 的频率策略。